// Dessiner le diagramme
function drawDiagram() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    // Calculer les positions des nœuds
    const nodeRadius = 50;
    const horizontalSpacing = 200;
    const verticalSpacing = 150;
    const startX = 100;
    const startY = 100;
    // Organiser les tâches par niveaux (topological sort simplifié)
    const positions = {};
    let maxLevel = 0;
    // Tâches sans dépendances au niveau 0
    let tasksAtLevel0 = 0;
    taches.forEach((tache) => {
        if (tache.dependances.length === 0) {
            positions[tache.code] = {
                x: startX,
                y: startY + (tasksAtLevel0 * verticalSpacing),
                level: 0
            };
            tasksAtLevel0++;
        }
    });
    // Placer les autres tâches
    let placed = Object.keys(positions).length;
    let iterations = 0;
    const maxIterations = 100;
    while (placed < taches.length && iterations < maxIterations) {
        let placedInThisIteration = false;
        taches.forEach(tache => {
            if (!positions[tache.code]) {
                // Vérifier si toutes les dépendances sont placées
                const allDepsPlaced = tache.dependances.every(dep => positions[dep]);
                if (allDepsPlaced) {
                    // Calculer le niveau basé sur les dépendances
                    let maxDepLevel = -1;
                    if (tache.dependances.length > 0) {
                        maxDepLevel = Math.max(...tache.dependances.map(dep => positions[dep].level));
                    }
                    const level = maxDepLevel + 1;
                    
                    // Compter les tâches déjà à ce niveau
                    const tasksAtLevel = Object.values(positions).filter(p => p.level === level).length;
                    
                    positions[tache.code] = {
                        x: startX + (level * horizontalSpacing),
                        y: startY + (tasksAtLevel * verticalSpacing),
                        level: level
                    };
                    
                    maxLevel = Math.max(maxLevel, level);
                    placed++;
                    placedInThisIteration = true;
                }
            }
        });
        
        // Si aucune tâche n'a été placée dans cette itération, on risque une boucle infinie
        if (!placedInThisIteration) {
            console.error("Impossible de placer toutes les tâches. Dépendances circulaires possibles.");
            break;
        }
        
        iterations++;
    }
    
    // Vérifier si toutes les tâches ont été placées
    if (placed < taches.length) {
        console.warn(`Seulement ${placed} sur ${taches.length} tâches ont été placées.`);
    }
    
    // Dessiner les flèches (dépendances)
    taches.forEach(tache => {
        const fromPos = positions[tache.code];
        if (!fromPos) return;
        
        tache.dependances.forEach(depCode => {
            const toPos = positions[depCode];
            if (fromPos && toPos) {
                const isCritical = cheminCritique.includes(tache.code) && cheminCritique.includes(depCode);
                drawArrow(toPos.x, toPos.y, fromPos.x, fromPos.y, nodeRadius, isCritical);
            }
        });
    });
    // Dessiner les nœuds
    taches.forEach(tache => {
        const pos = positions[tache.code];
        if (pos) {
            drawNode(pos.x, pos.y, tache, nodeRadius);
        }
    });

    ctx.restore();
}

// Dessiner un nœud
function drawNode(x, y, tache, radius) {
    const isCritical = cheminCritique.includes(tache.code);

    // Cercle
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fillStyle = isCritical ? '#fee2e2' : '#dbeafe';
    ctx.fill();
    ctx.strokeStyle = isCritical ? '#ef4444' : '#3b82f6';
    ctx.lineWidth = isCritical ? 3 : 2;
    ctx.stroke();

    // Code de la tâche
    ctx.fillStyle = '#000';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(tache.code, x, y - 15);

    // Nom de la tâche (tronqué)
    ctx.font = '12px Arial';
    const maxLength = 10;
    const nom = tache.nom.length > maxLength ? tache.nom.substring(0, maxLength) + '...' : tache.nom;
    ctx.fillText(nom, x, y + 5);

    // Durée
    ctx.font = '11px Arial';
    ctx.fillStyle = '#666';
    ctx.fillText(tache.duree + 'j', x, y + 20);

    // Dates (si disponibles)
    if (tache.date_debut_tot !== null && tache.date_debut_tot !== undefined) {
        ctx.font = '10px Arial';
        ctx.fillText(`T: ${tache.date_debut_tot}`, x - 25, y + 35);
    }
    if (tache.date_fin_tot !== null && tache.date_fin_tot !== undefined) {
        ctx.font = '10px Arial';
        ctx.fillText(`F: ${tache.date_fin_tot}`, x + 25, y + 35);
    }
}

// Dessiner une flèche
function drawArrow(fromX, fromY, toX, toY, nodeRadius, isCritical) {
    const angle = Math.atan2(toY - fromY, toX - fromX);
    const startX = fromX + nodeRadius * Math.cos(angle);
    const startY = fromY + nodeRadius * Math.sin(angle);
    const endX = toX - nodeRadius * Math.cos(angle);
    const endY = toY - nodeRadius * Math.sin(angle);
    
    // Ligne de la flèche
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.strokeStyle = isCritical ? '#ef4444' : '#9ca3af';
    ctx.lineWidth = isCritical ? 3 : 1.5;
    ctx.stroke();
    
    // Pointe de la flèche
    const headLength = 15;
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(
        endX - headLength * Math.cos(angle - Math.PI / 6),
        endY - headLength * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
        endX - headLength * Math.cos(angle + Math.PI / 6),
        endY - headLength * Math.sin(angle + Math.PI / 6)
    );
    ctx.closePath();
    ctx.fillStyle = isCritical ? '#ef4444' : '#9ca3af';
    ctx.fill();
}